# 클린 아키텍처

## 클린 아키텍처란?

클린 아키텍처를 간단하게 말하면 `추상화 개념(Abstraction principle)`으로써 관심사를 분리시키고 의존도를 낮추는 것에 목적을 둔 아키텍처이다.

의존도를 낮추고 서로에게 주는 영향을 감소함으로써 유지보수의 용이성이 향상된다.

덕분에 낮은 비용으로 새로운 기능을 추가할 수 있다.

기본적인 원리는 종속성 규칙(Dependency Rule)을 지키는 것이다.

각 코드의 종속성은 외부에서 내부로 안쪽으로만 가리킬 수 있고, 고수준 정책(High level policy)이 저수준 정책(Low level policy)의 변경에 영향을 받지 않도록 하는 것이다.
> 여기서 의미하는 수준(Level)은 입/출력과의 거리를 의미하는 것으로,
고수준 정책은 보통 UI 또는 인터페이스와 거리가 먼 비즈니스 영역 Business Rules, Entities 등을 의미하며,
저수준 정책은 위와 반대로 거리가 가까운 인프라 영역이나 UI 영역 Presentation, Controllers 등을 의미한다.

***

## 클린 아키텍처의 레이어 구조

![image](https://blog.kakaocdn.net/dn/bOh3Wo/btrXn7BTilz/TWwETWquQqz79ndGY9gVc0/img.jpg)

안쪽에 위치할수록 고수준 정책이며, 바깥쪽에 위치할 수록 저수준 정책을 의미한다.

***

### 엔티티 (Entities)

의도에 따라 도메인 계층으로도 불리며, 엔티티 계층은 하나 이상의 프로그램 간에 공유될 수 있다는 가정하에 만드는 수명이 긴 객체이다.

즉, 재사용의 가능성이 높다는 것을 인지하고 외부에 의해 변경될 가능성을 낮추어야한다.

이곳에는 `Enterprise` 규모의 비즈니스 데이터를 포함하거나 핵심이 되는 비즈니스 규칙을 캡슐화한다.

### 유즈케이스 (Use cases)

애플리케이션 계층으로도 불리며, 어플리케이션 규모의 비즈니스 규칙을 포함한다.

이 레이어의 변경사항은 엔티티에 영향을 미쳐서는 안 되며, 인프라 단의 DB나 UI, 라이브러리와 같은 외부요소에 의해 영향을 받지 않는다는 것을 원칙으로 한다.

이는 즉 해당 계층의 수정은 응용 프로그램의 동작에 영향을 미친다는 의미이다.

### 인터페이스 어뎁터 (Interface Adapter)

어뎁터 계층은 DB나 Web, UI와 같은 바깥 계층에서 사용하기 편리하도록, 유즈케이스 또는 엔티티 계층에서 데이터를 변환하는 어뎁터의 집합이다.

흔히 MVC, MVVM과 같은 아키텍처를 포함하는 것이 이 영역으로 컨트롤러, 프레젠터, 게이트웨이 등이 속한다.

### 프레임워크와 드라이버 (Frameworks & Drivers)

인프라 계층이라고도 불리며, 가장 외부에 있는 레이어로 DB, 웹 프레임워크와 같은 세부 정보(Details)를 나타내는 계층이다.

이곳은 보통 글루 코드(Glue code)만 작성하며, 시간이 지남에 따라 구성이 변경될 수 있으므로 엔티티 계층(또는 도메인 계층)에 추상화(abstracted)하여 도메인 계층에 영향을 주지 않고 인터페이스를 수정하고 업데이트할 수 있다.

***

## 의존성과 데이터 흐름

![image](https://i.imgur.com/nV3CSDC.png)
위 그림 처럼, Domain은 다른 계층과 의존성없이 독립되고, Presentation과 Data만 Domain에 의존성을 가지도록 디자인 해야한다

![image](https://i.imgur.com/9B3CWsS.png)
위 그림은 Clean Architecture를 도입한 프로젝트의 기본적인 데이터 흐름이다.

사용자가 화면을 터치하는 등 액션을 발생시키면, ViewModel이 UseCase에게 액션에 대한 Output을 요청하고, 요청을 받은 UseCase는 Data 영역에 해당하는 DB 또는 Network에서 Output에 해당하는 Data를 가져오게 된다.

Data를 받은 UseCase는 Data를 해당 서비스에 사용되는 Model로 가공하여 ViewModel에게 반환하고, ViewModel은 전달받은 Model을 화면에 표시될 수 있는 타입으로 가공하여 화면에 표시하게 된다.

Domain이 다른 계층과 독립되면서, 위와 같이 데이터를 전달해야 하기 때문에 Swift에선 Protocol을 이용하여 계층 간 의존성 역전을 시켜 의존성을 분리시킨다.

***

## 장단점

장점
1. 의존성이 분리되어 있기 때문에 프로젝트를 확장, 수정 그리고 테스트가 용이하다.
2. 기능별 코드 분리가 용이하다. -> 응집도 향상
3. 협업 능력이 향상될 수 있다.
4. ViewControler 또는 ViewModel에 로직이 집중되는 것을 방지할 수 있다.

단점
1. 초기 개발 단계에 작업량이 많다.
2. 개념이 어렵고, 개인마다 계층 별로 코드를 분리하는 기준이 달라 팀원간 확실한 기준이 없으면, 혼돈을 줄 수 있다.
