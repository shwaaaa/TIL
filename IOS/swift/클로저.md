# 클로저(closure)

## 클로저란?

클로저는 먼저 두 가지 종류가 있다

`Named Closure` 와 `Unnamed Closure`

***

### Named Closure
```swift
func hihi() {
    print("hehe")
}
```
이렇게 우리가 자주 접하던 함수는 `Named Closure`이다!

이걸 굳이 클로저라 부르지 않고, 그냥 함수라고 부르는 것 뿐이다

### Unnamed Closure
```swift
let closure = { print("hihi") }
```

이렇게 이름을 붙이지 않고 사용하는 함수를 `Unnamed Closure`라고 부른다!

***

클로저는 `Named Clousre` & `Unnamed Closure` 둘다 포함하지만, 보통 `Unnamed Closure`를 말한다!

***

## 클로저 표현식

익명 함수인 만큼 `func`이란 키워드를 쓰지 않는다

```swift
{(Parameter) -> Return Type in 
    실행구문
}
```

또한 클로저는 다음과 같이 클로저 헤드와 클로저 바디로 이루어져 있는데

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbh4Y0S%2FbtqQKuqZrqn%2FxZkkNN630gNPH1XKhobyT1%2Fimg.png)

이 둘을 바로 구분지어주는 게 바로 `in` 이라는 키워드이다.

***

## 트레일링 클로저(Trailing Closure)

트레일링 클로저란?

함수의 마지막 파라미터가 클로저일 때 이를 파라미터 값 형식이 아닌 함수 뒤에 붙여 작성하는 문법이다.

이때, Argument Label은 생략된다

```swift
func doSomething(closure: () -> ()) {
    closure()
}

```

다음과 같이 클로저 하나만 파라미터로 받는 함수가 있을 때 이 함수를 호출하려면

```swift
doSomething(closure: { () -> () in
    print("Hello!")
})
```

이렇게 해야했다.

이렇게 클로저가 파라미터의 값 형식으로 함수 호출 구문 () 안에 작성되어 있는 것을 `Inline Closure` 라고 부른다.

근데 이 경우 마지막에 괄호도 }) 이렇게 되어 있어 헷갈리기 쉽고, 코드를 딱 봤을 때 해석도 쉽지 않다.

따라서 이 클로저를 파라미터 값 형식으로 보내는 것이 아닌,

함수의 가장 마지막에 클로저를 꼬리처럼 덧붙여서 쓸 수 있는데,

```swift
doSomething () { () -> () in
    print("Hello!")
}
```

이렇게 쓰는 것이 바로 `Trailing Closure`이다.

***

## 클로저의 경량 문법

클로저의 경량 문법이란,

말 그대로 문법을 최적화 하여 클로저를 단순하게 쓸 수 있게 하는 것이다.

```swift
func doSomething(closure: (Int, Int, Int) -> Int) {
    closure(1, 2, 3)
}
```

이러한 함수가 있을 때 이 함수는 파라미터로 받은 클로저를 실행하는데,

이때 클로저의 파라미터로 1, 2, 3이란 숫자를 넘겨주고 있다.

그렇다면, 실제 이 함수를 호출할 때 어떻게 했어야 했냐면,

```swift
doSomething(closure: { (a: Int, b: Int, c: Int) -> Int in
    return a + b + c
})
```

이렇게 클로저를 full로 작성 했어야 했다. ( + Inline Closure 방식)

***

### 파라미터 형식과 리턴 형식을 생략할 수 있다
```swift
doSomething(closure: { (a: Int, b: Int, c: Int) -> Int in
    return a + b + c
})
```

이들을 파라미터 형식과 리턴 형식을 생략하면 

```swift
doSomething(closure: { (a, b, c) in
    return a + b + c
})
```

이렇게 쓸 수 있다.

***

### Parameter Name은 Shortand Argument Names으로 대체하고, 이 경우 Parameter Name과 in 키워드를 삭제한다

`Shortand Argument Names`란 `Parameter Name` 대신 사용할 수 있는 것이다.

```swift
doSomething(closure: { (a, b, c) in
    return a + b + c
})
```

이때, 이 a b c 라는 Parameter Name 대신에

```
a → $0

b → $1

c → $2
```

이런 식으로 $와 index를 이용해 Parameter에 순서대로 접근하는 것이 

바로 `Shortand Argument Names`이다

따라서

```swift
doSomething(closure: {  
    return $0 + $1 + $2
})

```

이렇게 간단화 될 수 있다.

***

### 단일 리턴문만 남을 경우, return도 생략한다

단일 리턴문이란,

```swift
doSomething(closure: {  
    return $0 + $1 + $2
})
```

이렇게 클로저 내부에 코드가 return 구문 하나만 남은 경우를 말한다.

이때는 return이란 키워드도 다음과 같이

```swift
doSomething(closure: {  
     $0 + $1 + $2
})
```

생략할 수 있다.

***

### 클로저 파라미터가 마지막 파라미터면, 트레일링 클로저로 작성한다

트레일링 클로저를 배웠던 것처럼 마지막 파라미터인 클로저를 다음과 같이

```swift
doSomething() {  
     $0 + $1 + $2
}
```
이렇게 트레일링 클로저로 작성이 가능하다.

또한 파라미터가 하나인 경우 ()도 생략 가능하다고 배웠으므로

()에 값이 아무 것도 없다면 생략한다.

```swift
doSomething {  
     $0 + $1 + $2
}
```

***

## 클로저 캡처(Closure Capture)

`클로저 캡처(Closure Capture)`는 Swift에서 클로저가 외부 변수나 상수를 참조하고 저장하는 메커니즘이다

클로저가 스스로 값을 캡처하여 나중에 사용할 수 있게 해줌

클로저캡처는 두 가지 주요 유형으로 나눌 수 있다

`값 캡처(Value Capture)` 와 `참조 캡처(Reference Capture)`

***

## 값 캡처(Value Capture)

클로저가 외부 변수나 상수의 값을 캡처하여 그 값을 복사한다.

이렇게 하면 클로저가 해당 값에 대한 독립적인 복사본을 가지게 되며, 원래 변수나 상수의 변경에 영향을 받지 않는다.

***

## 참조 캡처(Reference Capture)

클로저가 외부 변수나 상수의 참조를 캡처한다.

이 경우 클로저와 외부 범위 간에 참조 관계가 형성되며, 클로저 내부에서 외부 변수나 상수의 변경이 클로저 외부에서도 반영될 수 있다.

***

클로저 캡처는 주로 클로저가 외부 범위에서 변수나 상수를 사용해야 할 때 발생

이를 통해 클로저가 데이터를 보존하고 공유할 수 있게된다.

***

값 캡처 예시

```swift
func makeIncrementer(incrementAmount: Int) -> () -> Int {
    var total = 0
    
    let incrementer: () -> Int = {
        total += incrementAmount // 클로저가 total 값을 캡처
        return total
    }
    
    return incrementer
}

let incrementByTwo = makeIncrementer(incrementAmount: 2)
print(incrementByTwo()) // 출력: 2
print(incrementByTwo()) // 출력: 4
```

***

참조 캡처 예시

```swift
class Example {
    var value = 0
    init() {}
    
    lazy var closure: () -> Int = {
        self.value += 1 // 참조 캡처: self를 사용하여 value 속성을 참조
        return self.value
    }
}

let exampleInstance = Example()
let closure = exampleInstance.closure

print(closure()) // 출력: 1
print(closure()) // 출력: 2
```
