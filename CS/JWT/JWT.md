# JWT

## JWT란?

JWT(Json Web Token)은 위와 같은 일련의 과정 속에서 나타난 하나의 인터넷 표준 인증 방식 이다.

JWT는 웹 표준을 따르고 있으며, JSON 객체를 사용하여 정보를 전달한다.

그리고, 필요한 모든 정보를 한 객체에 담아서 전달하기 때문에 JWT 한 가지로 인증을 마칠 수 있다.

***

## JWT의 구조

```
HEADER . PAYLOAD . SIGNATURE
  헤더      내용        서명
```

위와 같이 헤더, 내용, 서명이 '.(dot)'을 구분자로 하여 JWT 토큰 1개를 이룬다

### Header

![image](https://cdn.discordapp.com/attachments/1098858102582956064/1188443394545041561/2023-12-24_8.29.37.png?ex=659a8b29&is=65881629&hm=1cc4700c19486e9a30e23378a0921598ed1d98de80d8eb544cd9fd68f09877f3&)

header에는 보통 토큰의 타입이나, 서명 생성에 어떤 알고리즘이 사용되었는지 저장한다.

지금 같은 경우에는 현재 토큰의 타입이 JWT이고, 앞서 이야기했던 개인키로 HS512 알고리즘이 적용되어 암호화가 되어있다고 확인할 수 있다.

### Payload

![image](https://cdn.discordapp.com/attachments/1098858102582956064/1188443823278411797/2023-12-24_8.31.19.png?ex=659a8b8f&is=6588168f&hm=33fbdda70b7f2a655482ffaea503a060930c4cd8e2f51ac75d9574de3649c621&)

payload에는 보통 Claim이라는 사용자에 대한, 혹은 토큰에 대한 property를 key-value의 형태로 저장한다.

Claim이라는 말 그대로 토큰에서 사용할 정보의 조각인 셈이다.

표준 스펙상 key의 이름은 3글자로 되어있다. JWT의 핵심 목표는 사용자에 대한, 토큰에 대한 표현을 압축하는 것이기 때문에 이를 정의한 것이라고 볼 수 있다.

1. iss (Issuer) : 토큰 발급자
2. sub (Subject) : 토큰 제목 - 토큰에서 사용자에 대한 식별 값이 됨
3. aud (Audience) : 토큰 대상자
4. exp (Expiration Time) : 토큰 만료 시간
5. nbf (Not Before) : 토큰 활성 날짜 (이 날짜 이전의 토큰은 활성화되지 않음을 보장)
6. iat (Issued At) : 토큰 발급 시간
7. jti (JWT Id) : JWT 토큰 식별자 (issuer가 여러 명일 때 이를 구분하기 위한 값)

이러한 표준 스펙으로 정의되어있는 Claim 스펙이 있다는 것이지, 꼭 이 7가지를 모두 포함해야 하는 것은 아니고, 상황에 따라 해당 서버가 가져야 할 인증 체계에 따라 사용하면 된다.

여기서 중요한 것은 payload에 **민감한 정보를 담지 않는 것이다**

header와 payload는 특별한 암호화가 걸려있는 것이 아니기 때문에 누구나 jwt를 가지고 디코딩을 한다면 header나 payload에 담긴 값을 알 수 없기 떄문이다.

### Signature

가장 중요하다고 할 수 있는 서명은 지금까지 Header와 Player를 보여줄 때는 인코딩 되어있던 값을 위처럼 합치고 이를 서버가 가지고 있는 개인키를 가지고 암호화되어있는 상태이다.

따라서 signature는 서버에 있는 개인키로만 암호화를 풀 수 있으므로 다른 클라이언트는 임의로 Signature를 복호화할 수 없다

***

## Refresh Token

JWT는 Stateless이기 때문에 서버에서 상태를 관리하지 않는다. 다시 말해 액세스 토큰으로 JWT를 사용하여 사용자 검증을 진행하면 서버에서 토큰의 상태를 제어할 수 없다.

일반적으로 우리가 어떤 웹사이트에 로그인하여 이용하게 되면 웹사이트를 이용하는 동안에는 자동으로 로그아웃 되는 경우가 없다. 하지만 액세스 토큰만 사용하는 웹사이트는, 이용 중에 토큰이 만료되면 다음 서비스를 이용하려다가 갑자기 로그아웃되거나 오류 메시지를 보게 될 것이다.

또한, 외부의 공격자가 토큰을 탈취한다면 탈취당한 토큰이 만료될 때까지 속수무책이라는 문제도 있다.

이렇게 액세스 토큰만 사용하면 서버에서 토큰의 상태를 변경할 수 없기 때문에, 토큰의 유효시간이 짧다면 사용자는 서비스 이용중에 토큰의 유효시간이 갱신되지 않으니 자꾸 로그아웃되어 짜증날 것이고 토큰의 유효시간이 길다면 보안상의 문제가 될 수 있다.

이러한 문제는 리프레시 토큰을 사용하여 어느정도 해결해볼 수 있다. 액세스 토큰의 유효시간을 짧게 하는 대신 유효시간이 긴 리프레시 토큰을 함께 발급하여 액세스 토큰 자체를 계속 갱신하는 것이다.

액세스 토큰의 유효시간을 짧게 설정했으니 액세스 토큰을 탈취당했을 때의 위험성도 줄어들게 된다. 리프레시 토큰을 탈취당했을 때도 리프레시 토큰은 사용자 정보를 전혀 담고있지 않으니 상대적으로 안전하다고 볼 수 있다.

***

1. 클라이언트에서 API를 호출하면 액세스 토큰이 유효한지 검사한다.
> - 액세스 토큰이 유효하면 API 응답을 반환한다.

2. 액세스 토큰이 만료되었다면 클라이언트에서는 리프레시 토큰을 추가로 요청 헤더에 담아서 다시 한번 API를 호출한다.
> - 액세스 토큰이 만료된 것이 아닌 이유로 유효하지 않은 경우에는 예외를 발생시켜 오류 응답을 반환한다.

3. 리프레시 토큰이 유효하면 새로운 액세스 토큰을 응답 헤더에 담아서 정상 응답을 반환한다.
> - 리프레시 토큰이 유효하지 않은 경우에는 예외를 발생시켜 오류 응답을 반환한다.
> - 만료된 액세스 토큰과 유효한 리프레시 토큰이 함께 요청 헤더에 담겨서 API가 호출될 때 액세스 토큰을 재발급하는 횟수를 제한한다.

***

## 장점

- 이미 토큰 자체가 인증된 정보이기 때문에 세션 저장소와 같은 별도의 인증 저장소가 "필수적"으로 필요하지 않다

- 세션과는 다르게 클라이언트의 상태를 서버가 저장해 두지 않아도 된다

- signature를 공통 키 개인키 암호화를 통해 막아두었기 때문에 데이터에 대한 보완성이 늘어난다.

- 다른 서비스에 이용할 수 있는 공통적인 스펙으로써 사용할 수 있다.

***

## 단점

- 쿠키, 세션 때와 다르게 base64 인코딩을 통한 정보를 전달하므로 전달량이 많다. 따라서 네트워크 전달 시 많은 데이터양으로 부하가 생길 수 있다.

- payload에는 암호화가 되어있지 않기 떄문에 민감 정보를 저장할 수 없다.

- 토큰이 탈취당하면 만료될 떄까지 대처가 불가능하다.